knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ggplot2)
library(knitr)
dat.2<-t(dat[1:2,4:6])
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ggplot2)
library(knitr)
library(HistData)
dat<-PolioTrials
prop_placebo = dat$Paralytic[2]/dat$Population[2]
prop_n_inoculate = dat$Paralytic[3]/dat$Population[3]
prob_success = (dat$Paralytic[2] + dat$Paralytic[3]) / (dat$Population[2] + dat$Population[3])
prob_greater = pbinom(dat$Paralytic[2], dat$Population[2], prob_success, lower.tail = FALSE)
dat.2<-t(dat[1:2,4:6])
dat.2<-data.frame(dat.2)
names(dat.2)<-c("Vaccinated","Placebo")
View(dat.2)
View(dat.2)
dat.2$prop_vaccinated <- dat.2$Vaccinated/sum(dat.2$Vaccinated)
dat.2$prop_placebo <- dat.2$Placebo/sum(dat.2$Placebo)
pop<-rep(row.names(dat.2),times=dat.2$Vaccinated+dat.2$Placebo)
table(pop) # view the results
# Draw a sample of size k from the entries in this vector, that is a permutation of length k.
k<-10
samp.perm<-sample(pop,k)
outcome.prop
outcome.prop<-
(dat.2$Vaccinated+dat.2$Vaccinated)/sum(dat.2$Vaccinated+dat.2$Vaccinated)
outcome.prop
k<-10
set.seed(34567)
samp<-sample(c("Paralytic","NonParalytic","FalseReports"),k,replace=TRUE,prob=outcome.prop)
samp
# Total the number of each type of outcome in the sample.
counts<-table(samp)
counts
# Calculate the proportion each type of outcome in the sample.
props<-counts/sum(counts)
props
# Make two vectors of proportions
## Start by drawing two samples
k1<-10
k2<-20
set.seed(34567)
samp1<-sample(c("Paralytic","NonParalytic","FalseReports"),k1,
replace=TRUE,prob=outcome.prop)
samp2<-sample(c("Paralytic","NonParalytic","FalseReports"),k2,
replace=TRUE,prob=outcome.prop)
## Total the number of each type of outcome in each sample.
counts1<-table(samp1)
counts2<-table(samp2)
## Calculate the proportion each type of outcome in each sample.
props1<-counts1/sum(counts1)
props2<-counts2/sum(counts2)
# Calculate the Euclidean distance between two vectors.
dist.eu<-sqrt(sum((props1-props2)^2))
# Calculate the sum of the absolute differences in each position for
# two vectors.
dist.mann<-sum(abs(props1-props2))
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ggplot2)
library(knitr)
library(HistData)
dat<-PolioTrials
prop_placebo = dat$Paralytic[2]/dat$Population[2]
prop_n_inoculate = dat$Paralytic[3]/dat$Population[3]
prob_success = (dat$Paralytic[2] + dat$Paralytic[3]) / (dat$Population[2] + dat$Population[3])
prob_greater = pbinom(dat$Paralytic[2] -1, dat$Population[2], prob_success, lower.tail = FALSE)
dat.2<-t(dat[1:2,4:6])
dat.2<-data.frame(dat.2)
names(dat.2)<-c("Vaccinated","Placebo")
dat.2$prop_vaccinated <- dat.2$Vaccinated/sum(dat.2$Vaccinated)
dat.2$prop_placebo <- dat.2$Placebo/sum(dat.2$Placebo)
# Create a vector of the all the outcomes
# with the correct number of repetitions.
pop<-rep(row.names(dat.2),times=dat.2$Vaccinated+dat.2$Placebo)
table(pop) # view the results
# Draw a sample of size k from the entries in this vector, that is a permutation of length k.
k<-10
samp.perm<-sample(pop,k)
# Create a vector of the proportion of times each outcome was
# observed in the two groups put together.
outcome.prop<-
(dat.2$Vaccinated+dat.2$Vaccinated)/sum(dat.2$Vaccinated+dat.2$Vaccinated)
outcome.prop
# Sample the vector ("Paralytic","NonParalytic","FalseReports") k times according to the
# probabilites in "rating.prop"
k<-10
set.seed(34567)
samp<-sample(c("Paralytic","NonParalytic","FalseReports"),k,replace=TRUE,prob=outcome.prop)
samp
# Total the number of each type of outcome in the sample.
counts<-table(samp)
counts
# Calculate the proportion each type of outcome in the sample.
props<-counts/sum(counts)
props
# Make two vectors of proportions
## Start by drawing two samples
k1<-10
k2<-20
set.seed(34567)
samp1<-sample(c("Paralytic","NonParalytic","FalseReports"),k1,
replace=TRUE,prob=outcome.prop)
samp2<-sample(c("Paralytic","NonParalytic","FalseReports"),k2,
replace=TRUE,prob=outcome.prop)
## Total the number of each type of outcome in each sample.
counts1<-table(samp1)
counts2<-table(samp2)
## Calculate the proportion each type of outcome in each sample.
props1<-counts1/sum(counts1)
props2<-counts2/sum(counts2)
# Calculate the Euclidean distance between two vectors.
dist.eu<-sqrt(sum((props1-props2)^2))
# Calculate the sum of the absolute differences in each position for
# two vectors.
dist.mann<-sum(abs(props1-props2))
pop<-rep(row.names(dat.2),times=dat.2$Vaccinated+dat.2$Placebo)
table(pop) # view the results
outcome.prop<-
(dat.2$Vaccinated+dat.2$Placebo)/sum(dat.2$Vaccinated+dat.2$Placebo)
outcome.prop
sum(outcome.prop)
test_stat <- sqrt(sum(dat.2$prop_vaccinated - dat.2$prop_placebo)^2)
test_stat
test_stat <- sqrt(sum((dat.2$prop_vaccinated - dat.2$prop_placebo)^2))
test_stat
n <- 10000
k1 <- sum(dat.2$Vaccinated)
k1
k2 <- sum(dat.2$Placebo)
k2
samp1 <- sample(c("Paralytic", "NonParalytic", "FalseReports"), k1, replace=True, prob=outcome.prop)
samp1 <- sample(c("Paralytic", "NonParalytic", "FalseReports"), k1, replace=TRUE, prob=outcome.prop)
table(samp1)
samp2 <- sample(c("Paralytic", "NonParalytic", "FalseReports"), k2, replace=TRUE, prob=outcome.prop)
table(samp2)
n <- 10000
k1 <- sum(dat.2$Vaccinated)
k1
k2 <- sum(dat.2$Placebo)
k2
sim = rep(NA, n)
for(i in 1:n) {
samp1 <- sample(c("Paralytic", "NonParalytic", "FalseReports"), k1, replace=TRUE, prob=outcome.prop)
samp2 <- sample(c("Paralytic", "NonParalytic", "FalseReports"), k2, replace=TRUE, prob=outcome.prop)
counts1 <- table(samp1)
counts2 <- table(samp2)
dist.eu<-sqrt(sum((samp1 - samp2)^2))
sim[i] <- dist.eu
}
for(i in 1:n) {
samp1 <- sample(c("Paralytic", "NonParalytic", "FalseReports"), k1, replace=TRUE, prob=outcome.prop)
samp2 <- sample(c("Paralytic", "NonParalytic", "FalseReports"), k2, replace=TRUE, prob=outcome.prop)
counts1 <- table(samp1)
counts2 <- table(samp2)
props1<-counts1/sum(counts1)
props2<-counts2/sum(counts2)
dist.eu<-sqrt(sum((props1-props2)^2))
sim[i] <- dist.eu
}
for(i in 1:n) {
samp1 <- sample(c("Paralytic", "NonParalytic", "FalseReports"), k1, replace=TRUE, prob=outcome.prop)
samp2 <- sample(c("Paralytic", "NonParalytic", "FalseReports"), k2, replace=TRUE, prob=outcome.prop)
counts1 <- table(samp1)
counts2 <- table(samp2)
props1<-counts1/sum(counts1)
props2<-counts2/sum(counts2)
dist.eu<-sqrt(sum((props1-props2)^2))
sim[i] <- dist.eu
}
dat.temp <- data.frame(sim=sim)
ggplot(data=dat.temp, aes(x=sim)) + geom_histogram()
mean(sim>=test.stat)
mean(sim>=test_stat)
mean(sim>=test_stat)
ggplot(data=dat.temp, aes(x=sim)) + geom_histogram() +geom_vline(xintercept = test_stat, color='red')
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(knitr)
set.seed(12345)
N<-10000
samp<-rnorm(N)
theta.est<-function(n,s=samp){
m<-mean(s[1:n])
s2<-sum((s[1:n]-m)^2)/n
return(c(m,s2))
}
dat.consist<-t(sapply(1:N,theta.est))
dat.consist<-data.frame(dat.consist)
dat.consist$n<-1:N
names(dat.consist)<-c("mu.hat","sigma.sq.hat","n")
theta.est<-function(n,s=samp){
m<-mean(s[1:n])
s2<-sum((s[1:n]-m)^2)/n
return(c(m,s2))
}
dat.consist<-t(sapply(1:N,theta.est))
dat.consist<-data.frame(dat.consist)
dat.consist$n<-1:N
names(dat.consist)<-c("mu.hat","sigma.sq.hat","n")
mu <- mean(samp)
sig.sq <- sum((samp - mu)^2)/N
# examine mu
ggplot(data=dat.consist, aes(x=n, y=mu.hat)) + geom_point(aes(x=n, y=mu.hat)) + geom_line(aes(y=mu), color='red')
# examine sigma^2
ggplot(data=dat.consist, aes(x=n, y=mu.hat)) + geom_point(aes(x=n, y=sigma.sq.hat)) + geom_line(aes(y=sig.sq), color='red')
# plot M vs theta.hat.mu
ggplot(data=dat.unbiased, aes(x=m, y=mu.hat)) + geom_point(aes(x=m, y=mu.hat)) + geom_line(aes(y=mu), color='red')
set.seed(45678)
mat<-matrix(rnorm(10000*5),ncol=5)
mat <- data.frame(mat)
mat$mu.hat <- rowMeans(mat)
mat$sig.sq.hat <- apply(mat, 1,function(x){sum((x[1:5] - x[6])^2/5)})
theta.hat.mu <- dat.consist[dat.consist$n == 5,1]
theta.hat.sig.sq <- dat.consist[dat.consist$n == 5,2]
theta.hat.est <- function(n, d=mat) {
m <- mean(d$mu.hat[1:n])
s2 <- mean(d$sig.sq.hat[1:n])
return (c(m, s2))
}
dat.unbiased <- t(sapply(1:10000, theta.hat.est))
dat.unbiased <- t(sapply(1:10000, theta.hat.est))
dat.unbiased <- data.frame(dat.unbiased)
dat.unbiased$M <- 1:10000
dat.unbiased$M <- 1:10000
names(dat.unbiased) <- c('mu.hat', 'sig.sq.hat', 'm')
# plot M vs theta.hat.mu
ggplot(data=dat.unbiased, aes(x=m, y=mu.hat)) + geom_point(aes(x=m, y=mu.hat)) + geom_line(aes(y=mu), color='red')
# plot M vs theta.hat.sig.sq
ggplot(data=dat.unbiased, aes(x=m, y=sig.sq.hat)) + geom_point(aes(x=m, y=sig.sq.hat)) + geom_line(aes(y=sig.sq), color='red')
ns<-rep(c(2,5,20),times=c(3,3,3))
shapes<-rep(c(1,2,8),times=3)
scales<-rep(c(2,.5,.125),times=3)
dat.params<-data.frame(ns,shapes,scales)
val.mat<-matrix(rep(NA,100000*nrow(dat.params)),
ncol=nrow(dat.params))
set.seed(123456)
for(i in 1:nrow(dat.params)){
# Generate a matrix with 100,000 rows of n
# random values from a gamma distribution where the value of n
# and of the shape and scale of the gamma distribution come from the
# ith row of dat.params.
samp.mat<-matrix(rgamma(dat.params$ns[i]*100000,dat.params$shapes[i],
dat.params$scales[i]),nrow=100000)
# take the mean of each row and store the result in val.mat
val.mat[,i]=apply(samp.mat,1,mean)
}
val.stats<-function(x){
return(c(median(x),quantile(x,.75)-quantile(x,.25)))
}
params<-apply(val.mat,2,val.stats)
for(i in 1:ncol(val.mat)){
dat.temp<-data.frame(x=val.mat[,i])
g<-ggplot(dat.temp,aes(x=x))+
geom_histogram(aes(y=stat(density)),bins=50)+
labs(title=str_c("n=",dat.params$ns[i],", shape=",
dat.params$shapes[i],
", scale=",round(dat.params$scales[i],2)))+
stat_function(fun=dnorm,args=list(mean=params[1,i],
sd=params[2,i]/(2*qnorm(.75))))
print(g)
}
x_0.75 <- rep(NA, 10)
for (i in 1:10) {
x_0.75[i] <- qnorm(0.75, mean=0, sd=i)
}
x_0.75 <- data.frame(x_0.75)
x_0.75$sd <- 1:10
ggplot(x_0.75, aes(x=sd, y=x_0.75)) +
geom_point()
ns<-rep(c(10,50,1000), times=c(3, 3, 3))
ps<-rep(c(.5,.1,.01), times=3)
params<-data.frame(ns,ps)
View(params)
params$bins <- 1 / params$ns
means <-matrix(rep(NA,100000*nrow(params)),
ncol=nrow(params))
for(i in 1:nrow(params)){
sample <- matrix(rbinom(params$ns[i]*100000,1,params$ps[i]),nrow=100000)
means[,i]=apply(sample,1,mean)
}
for(i in 1:nrow(params)){
sample <- matrix(rbinom(params$ns[i]*100000,1,params$ps[i]),nrow=100000)
means[,i]=apply(sample,1,mean)
}
med_inqr <-apply(means,2,val.stats)
med_inqr <-apply(means,2,val.stats)
for(i in 1:ncol(means)){
dat.temp<-data.frame(x=means[,i])
g<-ggplot(dat.temp,aes(x=x))+
geom_histogram(aes(y=stat(density)),binwidth=params$bins[i])+
labs(title=str_c("n=",params$ns[i],", p=",
params$ps[i]))+
stat_function(fun=dnorm,args=list(mean=med_inqr[1,i],
sd=med_inqr[2,i]/(2*qnorm(.75))))
print(g)
}
mat$sig.sq.hat <- apply(mat, 1,function(x){sum((x[1:5] - x[6])^2/4)})
# dividing sum of squared differences by 4 instead of 5
mat$sig.sq.hat <- apply(mat, 1,function(x){sum((x[1:5] - x[6])^2/4)})
ggplot(data=dat.unbiased, aes(x=m, y=sig.sq.hat)) + geom_point(aes(x=m, y=sig.sq.hat)) + geom_line(aes(y=sig.sq), color='red')
dat.unbiased <- t(sapply(1:10000, theta.hat.est))
dat.unbiased <- data.frame(dat.unbiased)
dat.unbiased$M <- 1:10000
names(dat.unbiased) <- c('mu.hat', 'sig.sq.hat', 'm')
ggplot(data=dat.unbiased, aes(x=m, y=sig.sq.hat)) + geom_point(aes(x=m, y=sig.sq.hat)) + geom_line(aes(y=sig.sq), color='red')
setwd("~/Desktop/Personal/MSDS/21-Summer/COMP_4441_Prob_Stats_1/Final_examination")
knitr::opts_chunk$set(echo = TRUE)
library("BSDA")
load("dat_one_sample.RData")
qplot(dat_one_sample, geom='histogram', bins=10)
qplot(dat_one_sample, geom='histogram', bins=10)
knitr::opts_chunk$set(echo = TRUE)
library("BSDA")
qplot(dat_one_sample, geom='histogram', bins=10)
qplot(dat_one_sample, geom='histogram', bins=10)
knitr::opts_chunk$set(echo = TRUE)
library("BSDA")
library("ggplot2")
qplot(dat_one_sample, geom='histogram', bins=10)
ggqqplot(dat_one_sample)
knitr::opts_chunk$set(echo = TRUE)
library("BSDA")
library("ggplot2")
library("tidyverse")
ggqqplot(dat_one_sample)
library("ggpubr")
ggqqplot(dat_one_sample)
t.test(dat_one_sample, mu=0.1)
wilcox.test(dat_one_sample, mu=0.1)
SIGN.test(dat_one_sample, md=0.1)
load("dat_pre_post.RData")
ggplot(data=dat_pre_post, aes(x=pre, y=post)) + geom_point()
t.test(dat_pre_post$post - dat_pre_post$pre)
load("dat_two_sample.RData")
ggqqplot(data=dat_two_sample$val, facet.by=c("dat_two_sample$gp"))
ggplot(data=dat_two_sample, aes(x=val)) + geom_histogram(binwidth=3) + facet_grid(gp ~ .)
ggqqplot(data=dat_two_sample$val, facet.by=c("dat_two_sample$gp"))
ggplot(data=dat_two_sample, aes(x=val)) + geom_histogram(bins=4) + facet_grid(gp ~ .)
ggqqplot(data=dat_two_sample$val, facet.by=c("dat_two_sample$gp"))
ggplot(data=dat_two_sample, aes(x=val)) + geom_histogram(bins=8) + facet_grid(gp ~ .)
ggqqplot(data=dat_two_sample$val, facet.by=c("dat_two_sample$gp"))
ggplot(data=dat_two_sample, aes(x=val)) + geom_histogram(bins=6) + facet_grid(gp ~ .)
ggplot(data=dat_two_sample, aes(x=val, color=gp)) + geom_density()
t.test(data=dat_two_sample, val ~ gp)
wilcox.test(dat_two_sample$val[dat_two_sample$gp == "x"], dat_two_sample$val[dat_two_sample$gp == "y"])
wilcox.test(dat_two_sample$val[dat_two_sample$gp == "x"], dat_two_sample$val[dat_two_sample$gp == "y"], paired=FALSE)
load("mat.RData")
chisq.test(mat)
fisher.test(mat)
mod <- lm(post ~ pre, data=dat_pre_post)
summary(mod)
mod <- lm(post ~ pre, data=dat_pre_post)
summary(mod)$coefficients
summary(mod)
ggplot(data=dat_pre_post, aes(x=pre, y=post)) + geom_point() + geom_abline(intercept = mod$coefficients[1], slope = mod$coefficients[2])
View(mod)
View(mod)
ggqqplot(mod$fitted.values)
ggqqplot(mod$residuals)
ggqqplot(mod$residuals)
ggqqplot(mod$residuals)
ggqqplot(mod$residuals, title="Residuals")
ggqqplot(mod$residuals, title="Residuals Distribution")
ggplot(data=dat_two_sample, aes(x=val, color=gp)) + geom_density() + labels(title='X and Y Density of dat_two_sample')
ggplot(data=dat_two_sample, aes(x=val, color=gp)) + geom_density() + labs(title='X and Y Density of dat_two_sample')
ggqqplot(data=dat_two_sample$val, facet.by=c("dat_two_sample$gp"), title='X and Y Distribution of dat_two_sample$val')
ggplot(data=dat_two_sample, aes(x=val)) + geom_histogram(bins=6) +
facet_grid(gp ~ .)
ggplot(data=dat_pre_post, aes(x=pre, y=post)) + geom_point() + labs(title='pre v post')
ggplot(data=dat_pre_post, aes(x=pre, y=post)) + geom_point() + geom_abline(intercept = mod$coefficients[1], slope = mod$coefficients[2]) + labs(title='pre vs post with fitted line')
setwd("~/Desktop/Personal/MSDS/21-Summer/COMP_4441_Prob_Stats_1/comp4441_final")
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ggpubr)
library(ggplot2)
required_packages <- c('MASS', 'rcompanion', 'lsr', 'vcd', 'DescTools')
for (p in required_packages) {
if(!require(p,character.only = TRUE)) {
install.packages(p, dep = TRUE)
}
}
library("graphics")
library("gplots")
require(foreign)
require(nnet)
require(reshape2)
library(caret)
library(plyr)
library(Rfast2)
library(dplyr)
dat <- dat %>% na_if("") %>% na.omit
dat <- dat[dat$date < as.Date('2021-01-01'),]
dat<-read.csv("fatal-police-shootings-data.csv")
dat$date <- as.Date(dat$date)
dat <- dat %>% na_if("") %>% na.omit
dat <- dat[dat$date < as.Date('2021-01-01'),]
by_year <- data.frame(year=2015:2020)
by_year$A <- (dat[dat$race == "A",] %>% mutate(year=format(date, "%Y")) %>% group_by(year) %>% tally())$n
by_year$B <- (dat[dat$race == "B",] %>% mutate(year=format(date, "%Y")) %>% group_by(year) %>% tally())$n
by_year$W <- (dat[dat$race == "W",] %>% mutate(year=format(date, "%Y")) %>% group_by(year) %>% tally())$n
by_year$H <- (dat[dat$race == "H",] %>% mutate(year=format(date, "%Y")) %>% group_by(year) %>% tally())$n
by_year$N <- (dat[dat$race == "N",] %>% mutate(year=format(date, "%Y")) %>% group_by(year) %>% tally())$n
by_year$total <- apply(by_year[,2:6], 1, sum)
by_year
by_long <- by_year %>%
gather(race, total, -year)
ggplot(data=by_long, aes(x=year, y=total, color=race)) + geom_line()
for (i in 2:6) {
print(ggqqplot(by_year[,i]))
}
t.test(by_year$W - by_year$B)
t.test(by_year$total - by_year$W)
t.test(by_year$B - by_year$H)
illness <- dat %>% mutate(year=format(date, "%Y")) %>%
group_by(year, signs_of_mental_illness) %>% tally()
t.test(data=illness, n ~ signs_of_mental_illness)
props <- data.frame(year=2015:2020, n=illness[illness$signs_of_mental_illness == "True", 3])
illness$year <- as.integer(illness$year)
tot.pop <- aggregate(x = illness$n, by=list(illness$year), FUN=sum)
colnames(tot.pop) <- c("year", "n")
tot.pop$prop <- props$n / tot.pop$n
t.test(tot.pop$prop, mu=0.206)
props <- data.frame(year=2015:2020, n=illness[illness$signs_of_mental_illness == "True", 3])
illness$year <- as.integer(illness$year)
tot.pop <- aggregate(x = illness$n, by=list(illness$year), FUN=sum)
colnames(tot.pop) <- c("year", "n")
tot.pop$prop <- props$n / tot.pop$n
tot.pop
t.test(tot.pop$prop, mu=0.206)
gen_samp <- function() {
gen_pop <- data.frame(id=1:5000, race=sample(unique(dat$race)[0:5],500000, replace=TRUE, prob = c(0.059, 0.601, 0.185, 0.134, 0.028)))
gen_pop$shot <- sample(c(0, 1), 5000, replace=TRUE, prob = c(314/315, 1/315))
gen_pop <- gen_pop[gen_pop$shot == 1,]
gen_pop <- gen_pop %>% count(race)
return (gen_pop$n)
}
mat <- matrix(rep(NA, 5000), ncol=5)
for (i in 1:1000) {
mat[i,] = gen_samp()
}
View(dat)
